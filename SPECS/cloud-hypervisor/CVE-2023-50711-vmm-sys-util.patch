commit 155a240bcff3007182776e36728f79ff40fe4d3d
Author: sindhu <lakarri@microsoft.com>
Date:   Thu Jan 18 16:14:30 2024 +0000

    Add vmm-sys-util to the list of patched vendor crates

diff --git a/Cargo.toml b/Cargo.toml
index 69ce35d..2d9e89d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -54,6 +54,7 @@ vm-memory = "0.10.0"
 kvm-bindings = { git = "https://github.com/cloud-hypervisor/kvm-bindings", branch = "ch-v0.6.0-tdx" }
 kvm-ioctls = { git = "https://github.com/rust-vmm/kvm-ioctls", branch = "main" }
 versionize_derive = { git = "https://github.com/cloud-hypervisor/versionize_derive", branch = "ch" }
+vmm-sys-util = { path="vendor/vmm-sys-util/" }
 
 [dev-dependencies]
 dirs = "5.0.0"
commit 5d4b972efd57964b076231d37b254e60a49350bd
Author: Sindhu Karri <lakarri@microsoft.com>
Date:   Tue Jan 16 09:54:26 2024 +0000
Subject: [PATCH] fix: deserialization issue of FamStructWrapper with serde

    Source commit: https://github.com/rust-vmm/vmm-sys-util/commit/30172fca2a8e0a38667d934ee56682247e13f167

diff --git a/vendor/vmm-sys-util/Cargo.toml b/vendor/vmm-sys-util/Cargo.toml
index f1da15c..9def507 100644
--- a/vendor/vmm-sys-util/Cargo.toml
+++ b/vendor/vmm-sys-util/Cargo.toml
@@ -32,6 +32,8 @@ version = "1.0.27"
 optional = true
 [dev-dependencies.serde_json]
 version = "1.0.9"
+[dev-dependencies.bincode]
+version = "1.3.3"
 
 [features]
 with-serde = ["serde", "serde_derive"]
diff --git a/vendor/vmm-sys-util/src/fam.rs b/vendor/vmm-sys-util/src/fam.rs
index 0d62b0f..abdfd2d 100644
--- a/vendor/vmm-sys-util/src/fam.rs
+++ b/vendor/vmm-sys-util/src/fam.rs
@@ -99,7 +99,7 @@ impl fmt::Display for Error {
 ///         self.len as usize
 ///     }
 ///
-///     fn set_len(&mut self, len: usize) {
+///     unsafe fn set_len(&mut self, len: usize) {
 ///         self.len = len as u32
 ///     }
 ///
@@ -135,7 +135,12 @@ pub unsafe trait FamStruct {
     ///
     /// These type of structures contain a member that holds the FAM length.
     /// This method will set the value of that member.
-    fn set_len(&mut self, len: usize);
+    ///
+    /// # Safety
+    ///
+    /// The caller needs to ensure that `len` here reflects the correct number of entries of the
+    /// flexible array part of the struct.
+    unsafe fn set_len(&mut self, len: usize);
 
     /// Get max allowed FAM length
     ///
@@ -214,7 +219,11 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
             // SAFETY: Safe as long T follows the requirements of being POD.
             mem_allocator.push(unsafe { mem::zeroed() })
         }
-        mem_allocator[0].set_len(num_elements);
+        // SAFETY: The flexible array part of the struct has `num_elements` capacity. We just
+        // initialized this in `mem_allocator`.
+        unsafe {
+            mem_allocator[0].set_len(num_elements);
+        }
 
         Ok(FamStructWrapper { mem_allocator })
     }
@@ -270,8 +279,8 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
         &self.mem_allocator[0]
     }
 
-    /// Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.
-    pub fn as_mut_fam_struct(&mut self) -> &mut T {
+    // Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.
+    fn as_mut_fam_struct(&mut self) -> &mut T {
         &mut self.mem_allocator[0]
     }
 
@@ -382,7 +391,11 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
             self.mem_allocator[i] = unsafe { mem::zeroed() }
         }
         // Update the len of the underlying `FamStruct`.
-        self.as_mut_fam_struct().set_len(len);
+        // SAFETY: We just adjusted the memory for the underlying `mem_allocator` to hold `len`
+        // entries.
+        unsafe {
+            self.as_mut_fam_struct().set_len(len);
+        }
 
         // If the len needs to be decreased, deallocate unnecessary memory
         if additional_elements < 0 {
@@ -527,13 +540,23 @@ where
             {
                 use serde::de::Error;
 
-                let header = seq
+                let header: X = seq
                     .next_element()?
                     .ok_or_else(|| de::Error::invalid_length(0, &self))?;
                 let entries: Vec<X::Entry> = seq
                     .next_element()?
                     .ok_or_else(|| de::Error::invalid_length(1, &self))?;
 
+                if header.len() != entries.len() {
+                    let msg = format!(
+                        "Mismatch between length of FAM specified in FamStruct header ({}) \
+                         and actual size of FAM ({})",
+                        header.len(),
+                        entries.len()
+                    );
+                    return Err(V::Error::custom(msg));
+                }
+
                 let mut result: Self::Value = FamStructWrapper::from_entries(entries.as_slice())
                     .map_err(|e| V::Error::custom(format!("{:?}", e)))?;
                 result.mem_allocator[0] = header;
@@ -557,7 +580,7 @@ macro_rules! generate_fam_struct_impl {
                 self.$field_name as usize
             }
 
-            fn set_len(&mut self, len: usize) {
+            unsafe fn set_len(&mut self, len: usize) {
                 self.$field_name = len as $field_type;
             }
 
@@ -589,7 +612,7 @@ mod tests {
     const MAX_LEN: usize = 100;
 
     #[repr(C)]
-    #[derive(Default, PartialEq, Eq)]
+    #[derive(Default, Debug, PartialEq, Eq)]
     pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
     impl<T> __IncompleteArrayField<T> {
         #[inline]
@@ -1045,4 +1068,29 @@ mod tests {
         assert_eq!(wrapper2.as_mut_fam_struct().flags, 2);
         assert_eq!(wrapper2.as_slice(), [0, 0, 0, 3, 14, 0, 0, 1]);
     }
+
+    #[cfg(feature = "with-serde")]
+    #[test]
+    fn test_bad_deserialize() {
+        #[repr(C)]
+        #[derive(Default, Debug, PartialEq, Serialize, Deserialize)]
+        struct Foo {
+            pub len: u32,
+            pub padding: u32,
+            pub entries: __IncompleteArrayField<u32>,
+        }
+
+        generate_fam_struct_impl!(Foo, u32, entries, u32, len, 100);
+
+        let state = FamStructWrapper::<Foo>::new(0).unwrap();
+        let mut bytes = bincode::serialize(&state).unwrap();
+
+        // The `len` field of the header is the first to be serialized.
+        // Writing at position 0 of the serialized data should change its value.
+        bytes[0] = 255;
+
+        assert!(
+            matches!(bincode::deserialize::<FamStructWrapper<Foo>>(&bytes).map_err(|boxed| *boxed), Err(bincode::ErrorKind::Custom(s)) if s == *"Mismatch between length of FAM specified in FamStruct header (255) and actual size of FAM (0)")
+        );
+    }
 }
commit 0023b3e3f137062b3a94364c4b154532e7ac2082
Author: Sindhu Karri <lakarri@microsoft.com>
Date:   Tue Jan 16 10:50:50 2024 +0000
Subject: [PATCH] Backported patch to make as_mut_fam_struct() unsafe public

    Source commit: e310864ba971b67a2a4e33ebfc826eda4296a0c6 in vmm-sys-util
    PR link: https://github.com/rust-vmm/vmm-sys-util/pull/215

diff --git a/vendor/vmm-sys-util/src/fam.rs b/vendor/vmm-sys-util/src/fam.rs
index abdfd2d..caa7304 100644
--- a/vendor/vmm-sys-util/src/fam.rs
+++ b/vendor/vmm-sys-util/src/fam.rs
@@ -50,6 +50,8 @@ impl fmt::Display for Error {
 /// * the implementer should be a POD
 /// * the implementor should contain a flexible array member of elements of type `Entry`
 /// * `Entry` should be a POD
+/// * the implementor should ensures that the FAM length as returned by [`FamStruct::len()`]
+///   always describes correctly the length of the flexible array member.
 ///
 /// Violating these may cause problems.
 ///
@@ -243,7 +245,8 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
         let mut adapter = FamStructWrapper::<T>::new(entries.len())?;
 
         {
-            let wrapper_entries = adapter.as_mut_fam_struct().as_mut_slice();
+            // SAFETY: We are not modifying the length of the FamStruct
+            let wrapper_entries = unsafe { adapter.as_mut_fam_struct().as_mut_slice() };
             wrapper_entries.copy_from_slice(entries);
         }
 
@@ -279,8 +282,13 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
         &self.mem_allocator[0]
     }
 
-    // Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.
-    fn as_mut_fam_struct(&mut self) -> &mut T {
+    /// Get a mut reference to the actual [`FamStruct`](trait.FamStruct.html) instance.
+    ///
+    /// # Safety
+    ///
+    /// Callers must not use the reference returned to modify the `len` filed of the underlying
+    /// `FamStruct`. See also the top-level documentation of [`FamStruct`].
+    pub unsafe fn as_mut_fam_struct(&mut self) -> &mut T {
         &mut self.mem_allocator[0]
     }
 
@@ -303,7 +311,8 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
     /// Modifying the container referenced by this pointer may cause its buffer
     /// to be reallocated, which would also make any pointers to it invalid.
     pub fn as_mut_fam_struct_ptr(&mut self) -> *mut T {
-        self.as_mut_fam_struct()
+        // SAFETY: We do not change the length of the underlying FamStruct.
+        unsafe { self.as_mut_fam_struct() }
     }
 
     /// Get the elements slice.
@@ -313,7 +322,8 @@ impl<T: Default + FamStruct> FamStructWrapper<T> {
 
     /// Get the mutable elements slice.
     pub fn as_mut_slice(&mut self) -> &mut [T::Entry] {
-        self.as_mut_fam_struct().as_mut_slice()
+        // SAFETY: We do not change the length of the underlying FamStruct.
+        unsafe { self.as_mut_fam_struct() }.as_mut_slice()
     }
 
     /// Get the number of elements of type `FamStruct::Entry` currently in the vec.
@@ -482,7 +492,7 @@ impl<T: Default + FamStruct> Clone for FamStructWrapper<T> {
 
         let mut adapter = FamStructWrapper { mem_allocator };
         {
-            let wrapper_entries = adapter.as_mut_fam_struct().as_mut_slice();
+            let wrapper_entries = adapter.as_mut_slice();
             wrapper_entries.copy_from_slice(self.as_slice());
         }
         adapter
@@ -933,7 +943,7 @@ mod tests {
             assert_eq!(payload[0], 0xA5);
             assert_eq!(payload[1], 0x1e);
         }
-        assert_eq!(wrapper.as_mut_fam_struct().padding, 5);
+        assert_eq!(unsafe { wrapper.as_mut_fam_struct() }.padding, 5);
         let data = wrapper.into_raw();
         assert_eq!(data[0].len, 2);
         assert_eq!(data[0].padding, 5);
@@ -1019,54 +1029,57 @@ mod tests {
         type FooFamStructWrapper = FamStructWrapper<Foo>;
 
         let mut wrapper = FooFamStructWrapper::new(0).unwrap();
-        wrapper.as_mut_fam_struct().index = 1;
-        wrapper.as_mut_fam_struct().flags = 2;
-        wrapper.as_mut_fam_struct().length = 3;
-        wrapper.push(3).unwrap();
-        wrapper.push(14).unwrap();
-        assert_eq!(wrapper.as_slice().len(), 3 + 2);
-        assert_eq!(wrapper.as_slice()[3], 3);
-        assert_eq!(wrapper.as_slice()[3 + 1], 14);
-
-        let mut wrapper2 = wrapper.clone();
-        assert_eq!(
-            wrapper.as_mut_fam_struct().index,
-            wrapper2.as_mut_fam_struct().index
-        );
-        assert_eq!(
-            wrapper.as_mut_fam_struct().length,
-            wrapper2.as_mut_fam_struct().length
-        );
-        assert_eq!(
-            wrapper.as_mut_fam_struct().flags,
-            wrapper2.as_mut_fam_struct().flags
-        );
-        assert_eq!(wrapper.as_slice(), wrapper2.as_slice());
-        assert_eq!(
-            wrapper2.as_slice().len(),
-            wrapper2.as_mut_fam_struct().length as usize
-        );
-        assert!(wrapper == wrapper2);
+        // SAFETY: We do play with length here, but that's just for testing purposes :)
+        unsafe {
+            wrapper.as_mut_fam_struct().index = 1;
+            wrapper.as_mut_fam_struct().flags = 2;
+            wrapper.as_mut_fam_struct().length = 3;
+            wrapper.push(3).unwrap();
+            wrapper.push(14).unwrap();
+            assert_eq!(wrapper.as_slice().len(), 3 + 2);
+            assert_eq!(wrapper.as_slice()[3], 3);
+            assert_eq!(wrapper.as_slice()[3 + 1], 14);
+
+            let mut wrapper2 = wrapper.clone();
+            assert_eq!(
+                wrapper.as_mut_fam_struct().index,
+                wrapper2.as_mut_fam_struct().index
+            );
+            assert_eq!(
+                wrapper.as_mut_fam_struct().length,
+                wrapper2.as_mut_fam_struct().length
+            );
+            assert_eq!(
+                wrapper.as_mut_fam_struct().flags,
+                wrapper2.as_mut_fam_struct().flags
+            );
+            assert_eq!(wrapper.as_slice(), wrapper2.as_slice());
+            assert_eq!(
+                wrapper2.as_slice().len(),
+                wrapper2.as_mut_fam_struct().length as usize
+            );
+            assert!(wrapper == wrapper2);
 
-        wrapper.as_mut_fam_struct().index = 3;
-        assert!(wrapper != wrapper2);
+            wrapper.as_mut_fam_struct().index = 3;
+            assert!(wrapper != wrapper2);
 
-        wrapper.as_mut_fam_struct().length = 7;
-        assert!(wrapper != wrapper2);
+            wrapper.as_mut_fam_struct().length = 7;
+            assert!(wrapper != wrapper2);
 
-        wrapper.push(1).unwrap();
-        assert_eq!(wrapper.as_mut_fam_struct().length, 8);
-        assert!(wrapper != wrapper2);
+            wrapper.push(1).unwrap();
+            assert_eq!(wrapper.as_mut_fam_struct().length, 8);
+            assert!(wrapper != wrapper2);
 
-        let mut wrapper2 = wrapper.clone();
-        assert!(wrapper == wrapper2);
+            let mut wrapper2 = wrapper.clone();
+            assert!(wrapper == wrapper2);
 
-        // Dropping the original variable should not affect its clone.
-        drop(wrapper);
-        assert_eq!(wrapper2.as_mut_fam_struct().index, 3);
-        assert_eq!(wrapper2.as_mut_fam_struct().length, 8);
-        assert_eq!(wrapper2.as_mut_fam_struct().flags, 2);
-        assert_eq!(wrapper2.as_slice(), [0, 0, 0, 3, 14, 0, 0, 1]);
+            // Dropping the original variable should not affect its clone.
+            drop(wrapper);
+            assert_eq!(wrapper2.as_mut_fam_struct().index, 3);
+            assert_eq!(wrapper2.as_mut_fam_struct().length, 8);
+            assert_eq!(wrapper2.as_mut_fam_struct().flags, 2);
+            assert_eq!(wrapper2.as_slice(), [0, 0, 0, 3, 14, 0, 0, 1]);
+        }
     }
 
     #[cfg(feature = "with-serde")]
